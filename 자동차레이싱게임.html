import React, { useState, useEffect, useRef } from 'react';
import { Trophy, Zap } from 'lucide-react';

const CarRacingGame = () => {
  const [gameState, setGameState] = useState('setup');
  const [countdown, setCountdown] = useState(3);
  const [numCars, setNumCars] = useState(10);
  const [numWinners, setNumWinners] = useState(3);
  const [namesInput, setNamesInput] = useState('');
  const [cars, setCars] = useState([]);
  const [activeBoosters, setActiveBoosters] = useState(new Set());
  const [boosterHistory, setBoosterHistory] = useState(new Set());
  const [boostersUsedCount, setBoostersUsedCount] = useState(0);
  const [obstacleHistory, setObstacleHistory] = useState(new Set());
  const [stoppedCars, setStoppedCars] = useState(new Map());
  const [obstaclesUsed100m, setObstaclesUsed100m] = useState(0);
  const [obstaclesUsed200m, setObstaclesUsed200m] = useState(0);
  const [finalBoostUsed, setFinalBoostUsed] = useState(false);
  const [activeFinalBoost, setActiveFinalBoost] = useState(null);
  const [finalBoostCount, setFinalBoostCount] = useState(0);
  const [finalBoostTarget, setFinalBoostTarget] = useState(0);
  const [winners, setWinners] = useState([]);
  const [confetti, setConfetti] = useState([]);
  const animationRef = useRef(null);
  const lastUpdateRef = useRef(Date.now());
  const boosterTimersRef = useRef({});
  const obstacleTimersRef = useRef({});
  const finalBoostTimerRef = useRef(null);

  const carColors = [
    '#ef4444', '#3b82f6', '#10b981', '#eab308', 
    '#a855f7', '#ec4899', '#6366f1', '#f97316',
    '#14b8a6', '#06b6d4', '#84cc16', '#f59e0b',
    '#f43f5e', '#8b5cf6', '#d946ef', '#0ea5e9',
    '#10b981', '#dc2626', '#2563eb', '#16a34a'
  ];

  const carModels = ['ğŸš—', 'ğŸš™', 'ğŸš•', 'ğŸï¸', 'ğŸš“', 'ğŸš‘', 'ğŸš', 'ğŸšš', 'ğŸš›', 'ğŸšœ', 'ğŸšŒ', 'ğŸš', 'ğŸš’', 'ğŸš”', 'ğŸš', 'ğŸš˜', 'ğŸš–', 'ğŸ›»', 'ğŸ‡', 'ğŸ›´'];

  const obstacleMessages = ['íƒ€ì´ì–´ í‘í¬...', 'í™”ì¥ì‹¤ ê°€ëŠ”ì¤‘...', 'í’ê²½ ë³´ëŠ”ì¤‘...'];

  const defaultNames = [
    'ìŠ¤í”¼ë“œ', 'ë²ˆê°œ', 'í­í’', 'ì§ˆí’', 'ë¡œì¼“', 'ë ˆì´ì„œ', 'í„°ë³´', 'ë¸”ë¦¬ì¸ ',
    'ì¬ë”', 'í”Œë˜ì‹œ', 'ì œíŠ¸', 'ë©”í…Œì˜¤', 'ì†Œë‹‰', 'ìœˆë“œ', 'í˜ë¼ë¦¬', 'ëŒë³´',
    'ë¶€ê°€í‹°', 'ë§¥ë¼ë Œ', 'í¬ë¥´ì‰', 'ë²¤ì¸ '
  ];

  const initializeCars = () => {
    const names = namesInput.trim() ? namesInput.trim().split(/\s+/) : [];
    const newCars = [];

    for (let i = 0; i < numCars; i++) {
      newCars.push({
        id: i,
        name: names[i] || defaultNames[i] || `ìë™ì°¨${i + 1}`,
        color: carColors[i % carColors.length],
        model: carModels[i % carModels.length],
        position: 0,
        speed: 4,
        finished: false,
        finishTime: null
      });
    }
    setCars(newCars);
    setActiveBoosters(new Set());
    setBoosterHistory(new Set());
    setBoostersUsedCount(0);
    setObstacleHistory(new Set());
    setStoppedCars(new Map());
    setObstaclesUsed100m(0);
    setObstaclesUsed200m(0);
    setFinalBoostUsed(false);
    setActiveFinalBoost(null);
    setFinalBoostCount(0);
    setFinalBoostTarget(0);
    setFinalBoostCount(0);
    setFinalBoostTarget(0);
    setWinners([]);
    setConfetti([]);
    boosterTimersRef.current = {};
    obstacleTimersRef.current = {};
    finalBoostTimerRef.current = null;
  };

  const createConfetti = () => {
    const newConfetti = [];
    for (let i = 0; i < 100; i++) {
      newConfetti.push({
        id: i,
        x: Math.random() * 100,
        y: -10,
        color: ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'][Math.floor(Math.random() * 6)],
        rotation: Math.random() * 360,
        speed: 2 + Math.random() * 3
      });
    }
    setConfetti(newConfetti);
  };

  const startRace = () => {
    if (cars.length === 0) {
      initializeCars();
    }
    setGameState('countdown');
    setCountdown(3);
  };

  useEffect(() => {
    if (gameState === 'countdown' && countdown > 0) {
      const timer = setTimeout(() => {
        setCountdown(countdown - 1);
      }, 1000);
      return () => clearTimeout(timer);
    } else if (gameState === 'countdown' && countdown === 0) {
      setGameState('racing');
      lastUpdateRef.current = Date.now();
    }
  }, [gameState, countdown]);

  const activateBooster = (carIndex) => {
    if (boosterHistory.has(carIndex)) return;

    setActiveBoosters(prev => new Set([...prev, carIndex]));
    setBoosterHistory(prev => new Set([...prev, carIndex]));

    if (boosterTimersRef.current[carIndex]) {
      clearTimeout(boosterTimersRef.current[carIndex]);
    }

    boosterTimersRef.current[carIndex] = setTimeout(() => {
      setActiveBoosters(prev => {
        const newSet = new Set(prev);
        newSet.delete(carIndex);
        return newSet;
      });
    }, 1000);
  };

  const activateObstacle = (carIndex, message) => {
    if (obstacleHistory.has(carIndex)) return;

    setStoppedCars(prev => new Map(prev).set(carIndex, message));
    setObstacleHistory(prev => new Set([...prev, carIndex]));

    if (obstacleTimersRef.current[carIndex]) {
      clearTimeout(obstacleTimersRef.current[carIndex]);
    }

    obstacleTimersRef.current[carIndex] = setTimeout(() => {
      setStoppedCars(prev => {
        const newMap = new Map(prev);
        newMap.delete(carIndex);
        return newMap;
      });
    }, 2500);
  };

  const activateFinalBoost = (carIndex) => {
    setActiveFinalBoost(carIndex);

    if (finalBoostTimerRef.current) {
      clearTimeout(finalBoostTimerRef.current);
    }

    finalBoostTimerRef.current = setTimeout(() => {
      setActiveFinalBoost(null);
    }, 2000);
  };

  const resetGame = () => {
    Object.values(boosterTimersRef.current).forEach(timer => clearTimeout(timer));
    Object.values(obstacleTimersRef.current).forEach(timer => clearTimeout(timer));
    if (finalBoostTimerRef.current) clearTimeout(finalBoostTimerRef.current);
    boosterTimersRef.current = {};
    obstacleTimersRef.current = {};
    finalBoostTimerRef.current = null;
    setGameState('setup');
    setCars([]);
    setNamesInput('');
    setCountdown(3);
    setActiveBoosters(new Set());
    setBoosterHistory(new Set());
    setBoostersUsedCount(0);
    setObstacleHistory(new Set());
    setStoppedCars(new Map());
    setObstaclesUsed100m(0);
    setObstaclesUsed200m(0);
    setFinalBoostUsed(false);
    setActiveFinalBoost(null);
    setWinners([]);
    setConfetti([]);
  };

  useEffect(() => {
    if (gameState !== 'racing') return;

    const animate = () => {
      const now = Date.now();
      const deltaTime = (now - lastUpdateRef.current) / 1000;
      lastUpdateRef.current = now;

      setCars(prevCars => {
        const updatedCars = prevCars.map((car, index) => {
          if (car.finished) return car;

          if (stoppedCars.has(index)) {
            return { ...car, speed: 0, position: car.position };
          }

          let newSpeed;
          if (activeFinalBoost === index) {
            newSpeed = 17;
          } else if (activeBoosters.has(index)) {
            newSpeed = 11;
          } else {
            newSpeed = 4 + Math.random() * 4;
          }

          const newPosition = Math.min(car.position + newSpeed * deltaTime * 0.5, 100);

          const justFinished = !car.finished && newPosition >= 100;

          return {
            ...car,
            speed: newSpeed,
            position: newPosition,
            finished: newPosition >= 100,
            finishTime: justFinished ? now : car.finishTime
          };
        });

        const maxBoosters = Math.floor(numCars / 2);
        if (boostersUsedCount < maxBoosters) {
          const eligibleCars = updatedCars.filter(car =>
            !car.finished && !boosterHistory.has(car.id) && car.position >= 10
          );

          if (eligibleCars.length > 0 && Math.random() < 0.004) {
            const randomCar = eligibleCars[Math.floor(Math.random() * eligibleCars.length)];
            activateBooster(randomCar.id);
            setBoostersUsedCount(prev => prev + 1);
          }
        }

        const obstacles100mTarget = Math.floor(numCars * 0.3);
        if (obstaclesUsed100m < obstacles100mTarget) {
          const eligibleCars = updatedCars.filter(car =>
            !car.finished && !obstacleHistory.has(car.id) && car.position >= 33 && car.position < 40
          );

          if (eligibleCars.length > 0 && Math.random() < 0.012) {
            const weightedCars = eligibleCars.map(car => ({
              car,
              weight: boosterHistory.has(car.id) ? 1.2 : 1
            }));

            const totalWeight = weightedCars.reduce((acc, obj) => acc + obj.weight, 0);
            let rand = Math.random() * totalWeight;
            let selectedCar = null;
            for (const { car, weight } of weightedCars) {
              if (rand < weight) {
                selectedCar = car;
                break;
              }
              rand -= weight;
            }

            if (selectedCar) {
              const randomMessage = obstacleMessages[Math.floor(Math.random() * obstacleMessages.length)];
              activateObstacle(selectedCar.id, randomMessage);
              setObstaclesUsed100m(prev => prev + 1);
            }
          }
        }

        const obstacles200mTarget = Math.floor(numCars * 0.3);
        if (obstaclesUsed200m < obstacles200mTarget) {
          const eligibleCars = updatedCars.filter(car =>
            !car.finished && !obstacleHistory.has(car.id) && car.position >= 66 && car.position < 73
          );

          if (eligibleCars.length > 0 && Math.random() < 0.012) {
            const weightedCars = eligibleCars.map(car => ({
              car,
              weight: boosterHistory.has(car.id) ? 1.2 : 1
            }));

            const totalWeight = weightedCars.reduce((acc, obj) => acc + obj.weight, 0);
            let rand = Math.random() * totalWeight;
            let selectedCar = null;
            for (const { car, weight } of weightedCars) {
              if (rand < weight) {
                selectedCar = car;
                break;
              }
              rand -= weight;
            }

            if (selectedCar) {
              const randomMessage = obstacleMessages[Math.floor(Math.random() * obstacleMessages.length)];
              activateObstacle(selectedCar.id, randomMessage);
              setObstaclesUsed200m(prev => prev + 1);
            }
          }
        }

        if (!finalBoostUsed) {
          const sortedCars = [...updatedCars]
            .filter(car => !car.finished)
            .sort((a, b) => b.position - a.position);

          const bottom50Percent = Math.ceil(sortedCars.length * 0.5);
          const bottomCars = sortedCars.slice(-bottom50Percent);
          const maxFinalBoost = Math.max(1, Math.floor(bottomCars.length * 0.5));

          if (finalBoostTarget === 0) {
            const randomTarget = Math.floor(Math.random() * maxFinalBoost) + 1;
            setFinalBoostTarget(randomTarget);
          }

          if (finalBoostCount < finalBoostTarget) {
            const eligibleCars = bottomCars.filter(car => 
              car.position >= 73 && 
              car.position < 76 && 
              activeFinalBoost !== car.id &&
              !updatedCars.some(c => c.id !== car.id && activeFinalBoost === c.id)
            );

            if (eligibleCars.length > 0) {
              const randomCar = eligibleCars[Math.floor(Math.random() * eligibleCars.length)];
              activateFinalBoost(randomCar.id);
              setFinalBoostCount(prev => prev + 1);
              
              if (finalBoostCount + 1 >= finalBoostTarget) {
                setFinalBoostUsed(true);
              }
            }
          }
        }

        const finishedCars = updatedCars
          .filter(car => car.finished)
          .sort((a, b) => a.finishTime - b.finishTime);

        if (finishedCars.length >= numWinners && winners.length === 0) {
          const finalWinners = finishedCars.slice(0, numWinners);
          setWinners(finalWinners);
          setGameState('finished');
          createConfetti();
        }

        return updatedCars;
      });

      if (gameState === 'racing') {
        animationRef.current = requestAnimationFrame(animate);
      }
    };

    animationRef.current = requestAnimationFrame(animate);

    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [gameState, activeBoosters, activeFinalBoost, winners.length, numWinners, stoppedCars, obstaclesUsed100m, obstaclesUsed200m, boosterHistory, obstacleHistory, boostersUsedCount, finalBoostUsed, numCars, finalBoostCount, finalBoostTarget]);

  useEffect(() => {
    if (confetti.length > 0) {
      const interval = setInterval(() => {
        setConfetti(prev =>
          prev.map(c => ({
            ...c,
            y: c.y + c.speed,
            rotation: c.rotation + 5
          })).filter(c => c.y < 110)
        );
      }, 50);
      return () => clearInterval(interval);
    }
  }, [confetti.length]);

  useEffect(() => {
    return () => {
      Object.values(boosterTimersRef.current).forEach(timer => clearTimeout(timer));
      Object.values(obstacleTimersRef.current).forEach(timer => clearTimeout(timer));
      if (finalBoostTimerRef.current) clearTimeout(finalBoostTimerRef.current);
    };
  }, []);

  if (gameState === 'setup') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-gray-900 via-blue-900 to-gray-900 flex items-center justify-center p-8">
        <div className="bg-white rounded-2xl shadow-2xl p-8 max-w-3xl w-full">
          <h1 className="text-5xl font-bold text-center mb-8 text-gray-800">ìë™ì°¨ ë ˆì´ì‹± (300m)</h1>

          <div className="space-y-6">
            <div>
              <label className="block text-lg font-semibold text-gray-700 mb-3">
                ì°¸ê°€ ìë™ì°¨ ìˆ˜: <span className="text-blue-600">{numCars}ëŒ€</span>
              </label>
              <input
                type="range"
                min="2"
                max="20"
                value={numCars}
                onChange={(e) => setNumCars(parseInt(e.target.value))}
                className="w-full h-3 bg-gray-200 rounded-lg appearance-none cursor-pointer"
              />
              <div className="flex justify-between text-sm text-gray-500 mt-1">
                <span>2ëŒ€</span>
                <span>20ëŒ€</span>
              </div>
            </div>

            <div>
              <label className="block text-lg font-semibold text-gray-700 mb-3">
                ë‹¹ì²¨ì ìˆ˜: <span className="text-green-600">{numWinners}ëª…</span>
              </label>
              <input
                type="range"
                min="1"
                max="10"
                value={numWinners}
                onChange={(e) => setNumWinners(parseInt(e.target.value))}
                className="w-full h-3 bg-gray-200 rounded-lg appearance-none cursor-pointer"
              />
              <div className="flex justify-between text-sm text-gray-500 mt-1">
                <span>1ëª…</span>
                <span>10ëª…</span>
              </div>
            </div>

            <div>
              <label className="block text-lg font-semibold text-gray-700 mb-3">
                ìë™ì°¨ ì´ë¦„ ì…ë ¥ (ê³µë°±ìœ¼ë¡œ êµ¬ë¶„)
              </label>
              <textarea
                value={namesInput}
                onChange={(e) => setNamesInput(e.target.value)}
                placeholder={`ì˜ˆì‹œ: ê°€ ë‚˜ ë‹¤ ë¼ ë§ˆ ë°” ì‚¬ ì•„ ì ì°¨\n${numCars}ê°œì˜ ì´ë¦„ì„ ê³µë°±ìœ¼ë¡œ êµ¬ë¶„í•´ì„œ ì…ë ¥í•˜ì„¸ìš”.\nì…ë ¥í•˜ì§€ ì•Šìœ¼ë©´ ê¸°ë³¸ ì´ë¦„ì´ ì‚¬ìš©ë©ë‹ˆë‹¤.`}
                className="w-full px-4 py-3 border-2 border-gray-300 rounded-lg focus:outline-none focus:border-blue-500 resize-none"
                rows="4"
              />
              <p className="text-sm text-gray-500 mt-2">
                ì…ë ¥ëœ ì´ë¦„: {namesInput.trim() ? namesInput.trim().split(/\s+/).length : 0}ê°œ / {numCars}ê°œ í•„ìš”
              </p>
            </div>

            <div className="bg-yellow-100 border-l-4 border-yellow-500 p-4">
              <p className="text-yellow-800 font-semibold flex items-center gap-2">
                <Zap className="w-5 h-5" />
                ì°¸ê°€ì¸ì›ì˜ ì ˆë°˜ì´ ëœë¤í•œ ì‹œê¸°ì— ë¶€ìŠ¤í„°ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤
              </p>
              <p className="text-yellow-800 text-sm mt-2">
                100m ì§€ì ì—ì„œ ì°¸ê°€ì¸ì›ì˜ 30%, 200m ì§€ì ì—ì„œ ì°¸ê°€ì¸ì›ì˜ 30%ê°€ ë°©í•´ìš”ì†Œë¥¼ ë°›ìŠµë‹ˆë‹¤
              </p>
              <p className="text-yellow-800 text-sm mt-1">
                ë¶€ìŠ¤í„°ë¥¼ ì¼ë˜ ì°¨ëŸ‰ì€ ë°©í•´ìš”ì†Œë¥¼ ë°›ì„ í™•ë¥ ì´ 20% ë” ë†’ìŠµë‹ˆë‹¤
              </p>
              <p className="text-yellow-800 text-sm mt-1 font-bold">
                220m ì§€ì ì—ì„œ í•˜ìœ„ê¶Œ 50% ì¤‘ ì ˆë°˜ì— í•´ë‹¹í•˜ëŠ” ì¸ì› ì¤‘ ëœë¤ìœ¼ë¡œ ë§‰íŒ ë¶€ìŠ¤íŠ¸ë¥¼ ë°›ìŠµë‹ˆë‹¤ (17m/s, 2ì´ˆ)
              </p>
            </div>

            <button
              onClick={startRace}
              className="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-4 px-6 rounded-lg transition transform hover:scale-105 text-xl"
            >
              ë ˆì´ìŠ¤ ì‹œì‘
            </button>
          </div>
        </div>
      </div>
    );
  }

  const trackHeight = Math.max(600, cars.length * 60);

  if (gameState === 'countdown') {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="text-center">
          <div className="text-white text-9xl font-bold mb-8 animate-pulse">
            {countdown}
          </div>
          <div className="text-white text-4xl font-bold">
            ë ˆì´ìŠ¤ ì¤€ë¹„ì¤‘...
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-900 p-4 overflow-hidden relative">
      {confetti.map(c => (
        <div
          key={c.id}
          className="absolute w-3 h-3 rounded-full"
          style={{
            left: `${c.x}%`,
            top: `${c.y}%`,
            backgroundColor: c.color,
            transform: `rotate(${c.rotation}deg)`,
            transition: 'all 0.05s linear'
          }}
        />
      ))}

      <div className="max-w-7xl mx-auto relative z-10">
        <div className="bg-gradient-to-r from-yellow-400 to-red-500 rounded-2xl shadow-2xl p-6 mb-4">
          <h1 className="text-4xl font-bold text-center text-white">
            ë ˆì´ìŠ¤ ì§„í–‰ ì¤‘ (300m íŠ¸ë™)
          </h1>
          <p className="text-center text-white text-lg mt-2">
            ìƒìœ„ {numWinners}ëª…ì´ ë‹¹ì²¨ë©ë‹ˆë‹¤
          </p>
        </div>

        <div className="relative rounded-2xl overflow-hidden bg-gray-800" style={{ height: `${trackHeight}px` }}>
          <div className="absolute left-0 top-0 bottom-0 w-4 bg-green-500 z-20">
            <div className="absolute inset-0 opacity-50" 
                 style={{
                   background: 'repeating-linear-gradient(0deg, transparent, transparent 10px, white 10px, white 20px)'
                 }} 
            />
          </div>
          <div className="absolute left-6 top-4 bg-green-500 text-white px-3 py-1 rounded font-bold text-sm z-20">
            START
          </div>

          <div className="absolute right-0 top-0 bottom-0 w-4 bg-white z-20">
            <div className="absolute inset-0" 
                 style={{
                   background: 'repeating-linear-gradient(45deg, black, black 10px, white 10px, white 20px)'
                 }} 
            />
          </div>
          <div className="absolute right-6 top-4 bg-red-500 text-white px-3 py-1 rounded font-bold text-sm z-20">
            FINISH
          </div>

          {cars.map((_, index) => (
            <div
              key={`line-${index}`}
              className="absolute left-0 right-0 border-t-2 border-gray-600"
              style={{ 
                top: `${((index + 1) / (cars.length + 1)) * 100}%`,
              }}
            />
          ))}

          {cars.map((car) => {
            const laneHeight = trackHeight / (cars.length + 1);
            const yPosition = laneHeight * (car.id + 1);
            const isStopped = stoppedCars.has(car.id);

            return (
              <div
                key={car.id}
                className="absolute transition-all duration-75"
                style={{
                  left: `calc(${car.position}% - 30px)`,
                  top: `${yPosition - 35}px`,
                }}
              >
                <div className="relative">
                  {activeBoosters.has(car.id) && (
                    <div className="absolute -left-20 top-1/2 transform -translate-y-1/2 flex gap-1">
                      <span className="text-4xl animate-pulse" style={{ animationDuration: '0.3s' }}>ğŸ”¥</span>
                      <span className="text-3xl animate-pulse opacity-80" style={{ animationDuration: '0.4s' }}>ğŸ”¥</span>
                      <span className="text-2xl animate-pulse opacity-60" style={{ animationDuration: '0.5s' }}>ğŸ”¥</span>
                    </div>
                  )}

                  {activeFinalBoost === car.id && (
                    <div className="absolute -left-32 top-1/2 transform -translate-y-1/2 flex gap-1 items-center">
                      <span className="text-5xl animate-pulse" style={{ animationDuration: '0.2s' }}>âš¡</span>
                      <span className="text-4xl animate-pulse opacity-80" style={{ animationDuration: '0.3s' }}>âš¡</span>
                      <span className="text-3xl animate-pulse opacity-60" style={{ animationDuration: '0.4s' }}>âš¡</span>
                    </div>
                  )}

                  <div
                    className="relative flex items-center justify-center transform transition-all duration-75"
                    style={{
                      transform: `${activeFinalBoost === car.id ? 'scale(1.5)' : activeBoosters.has(car.id) ? 'scale(1.3)' : 'scale(1)'} scaleX(-1)`,
                      filter: activeFinalBoost === car.id ? 'drop-shadow(0 0 30px #a855f7)' : activeBoosters.has(car.id) ? `drop-shadow(0 0 20px ${car.color})` : 'none'
                    }}
                  >
                    <span className="text-6xl">{car.model}</span>

                    {activeBoosters.has(car.id) && (
                      <Zap className="absolute -top-10 left-1/2 transform -translate-x-1/2 w-8 h-8 text-yellow-300 animate-bounce" style={{ transform: 'scaleX(-1) translateX(50%)' }} />
                    )}

                    {activeFinalBoost === car.id && (
                      <Zap className="absolute -top-12 left-1/2 transform -translate-x-1/2 w-12 h-12 text-purple-400 animate-bounce" style={{ transform: 'scaleX(-1) translateX(50%)', animationDuration: '0.3s' }} />
                    )}
                  </div>

                  <div 
                    className="absolute top-1/2 -left-20 transform -translate-y-1/2 whitespace-nowrap text-white px-3 py-1 rounded-full font-bold text-sm"
                    style={{
                      backgroundColor: car.color,
                      boxShadow: `0 0 10px ${car.color}`
                    }}
                  >
                    {car.name}
                  </div>

                  {isStopped && (
                    <div className="absolute -top-12 left-1/2 transform -translate-x-1/2 bg-red-500 text-white px-3 py-1 rounded font-bold text-xs whitespace-nowrap animate-bounce">
                      {stoppedCars.get(car.id)}
                    </div>
                  )}

                  {activeFinalBoost === car.id && (
                    <div className="absolute -top-16 left-1/2 transform -translate-x-1/2 bg-purple-500 text-white px-4 py-2 rounded-lg font-bold text-sm whitespace-nowrap animate-pulse shadow-lg" style={{ animationDuration: '0.3s' }}>
                      ë§‰íŒ ë¶€ìŠ¤íŠ¸!
                    </div>
                  )}
                </div>
              </div>
            );
          })}
        </div>

        {gameState === 'finished' && winners.length > 0 && (
          <div className="mt-8 bg-gradient-to-r from-yellow-400 via-yellow-500 to-yellow-600 rounded-xl p-8 text-center relative overflow-hidden">
            <Trophy className="w-24 h-24 mx-auto mb-6 text-white animate-bounce" />
            <h2 className="text-5xl font-bold text-white mb-8">
              ë‹¹ì²¨ì ë°œí‘œ
            </h2>

            <div className="bg-white bg-opacity-90 rounded-xl p-6 mb-6 max-w-2xl mx-auto">
              <div className="space-y-4">
                {winners.map((winner, index) => (
                  <div 
                    key={winner.id} 
                    className="flex items-center justify-between p-4 rounded-lg transform transition hover:scale-105"
                    style={{
                      backgroundColor: index === 0 ? '#ffd700' : index === 1 ? '#c0c0c0' : index === 2 ? '#cd7f32' : '#e5e7eb',
                      boxShadow: '0 4px 6px rgba(0,0,0,0.1)'
                    }}
                  >
                    <div className="flex items-center gap-4">
                      <div className="text-4xl font-bold text-gray-800 w-12">
                        {index + 1}
                      </div>
                      <div className="text-2xl font-bold text-gray-800">
                        {winner.name}
                      </div>
                    </div>
                    <div className="text-4xl">
                      {index === 0 && 'ğŸ‘‘'}
                      {index === 1 && 'ğŸ¥ˆ'}
                      {index === 2 && 'ğŸ¥‰'}
                      {index > 2 && 'ğŸ–ï¸'}
                    </div>
                  </div>
                ))}
              </div>
            </div>

            <button
              onClick={resetGame}
              className="bg-white text-yellow-600 font-bold py-4 px-12 rounded-lg hover:bg-gray-100 transition transform hover:scale-105 text-xl shadow-lg"
            >
              ìƒˆ ê²Œì„ ì‹œì‘
            </button>
          </div>
        )}
      </div>
    </div>
  );
};

export default CarRacingGame;